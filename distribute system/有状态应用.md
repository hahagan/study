# 一、有状态应用类型

有状态服务可以大体可以划分为两种：

1. 服务实例内含有数据，即数据未外置
2. 服务实例含有角色划分，服务具有拓扑结构



# 二、实例内含有数据应用

## 用户登录状态

该场景中，进程内存保存着用户的登录信息。但该类型的理想情况是可以通过一些方案转换为无状态服务模式。

### 多实例问题

服务扩展性很差，无法扩展多副本。多副本下如果客户端连接的服务端实例不同，将会导致登录信息丢失。因此将该类型视为有状态服务。

**当出现性能问题时，增加服务实例数量是最简单和最快速的解决办法。需要对服务代码细节进行优化，该行为见效慢，难度高**。

在该中应用下，当服务和服务器压力较大时，无法通过扩展实例数量，应对服务压力，无法通过负载降低服务所在节点资源压力。即满足性能需要和不利于资源调度。

### 解决方案

#### 状态外置

用户将登录信息外置到外部存储，多副本的登录状态依赖于外部存储。

例如通过redis缓存服务登录状态方式：

1. 用户第一次登录时，用户将登录状态存储到redis，并设置过期时间，并保存在实例内存内。
2. 用户再次请求时，若连接原实例，则可直接在内存内命中，若内存内不存在则对缓存进行获取。两处缓存皆不命中则认为无登录信息
3. 该方式有一个问题在于用户登出场景，用户登出后只有一个实例内存和redis缓存会清理登录状态，导致其他服务仍可继续登录。因此又有两种方案：
   1. 不使用实例内缓存，每次用户连接从redis缓存内获取数据
   2. 增加相应补偿方案。例如登出请求接收端向各个服务实例发送登出请求，销毁实例内内存的信息。这要求各个服务实例有接口表明自身内存版本信息，以及登出请求接收端能够获取所有正在运行的服务。该方法实现将会比较复杂，需要满足登出请求的事务性。一般只有在方案一性能优化需要降低对redis的压力和redis资源压力、网络IO压力和降低请求时延情况下使用。

#### 状态服务无关性

例如使用jwt和oauth等技术，而不是服务器保存会话，使得服务请求的会话信息与服务器无关，在客户端保存，服务端仅进行验证。

该方案的问题在于会话凭证的回收(登出)，当需要回收凭证，需要相应的补偿计划，类似于hydra方案。但本质上实际与方案一相同。

#### 连接粘性

通过连接特点，保证连接粘性，使得连接请求到同一个服务实例。

例如通过nginx代理路由能力，将同一客户端IP的请求负载到同一后端。

但该方式的局限在于：

1. 服务代理的路由能力是否支持，如何支持。例如后端实例数量增减后是否影响路由的行为，导致连接到不同服务实例上
2. 连接、请求和网络结构特性是否可用。例如连接粘性是通过源端IP进行识别和保证的，若存在nat模式进行地址伪装后，导致IP不可预估的变更。
3. 服务负载不均衡，最差情况下导致服务多实例优势丢失，浪费资源。

#### 集群化管理多节点实例

增加请求管理服务，实现分布式事务，保证各个节点内存状态一致，将请求应用到多个服务实例节点，并保证服务事务性。

本质上等于第一种状态外置方案中的登出补偿方案。

该方案的问题在于：

1. 实现复杂
2. 需要服务实例发现能力

### 总结

几种方案中建议使用第一或第二种方案进行状态外置，将压力和复杂性问题交给底层。在已使用第二种方案所说的认证行为下直接使用第二种方案。

## 定时任务应用

该场景中，应用实际负责定时执行特定应用。对应应用的管理全都在同一节点内的内存中。但该类应用被认为是有状态应用，往往是因为这种定时任务应用管理器的实现缺陷导致。

### 多实例问题

1. 当多个定时任务管理器发起定时任务时，由于多个定时任务的交叉执行导致任务执行结果的不可控。
2. 多定时任务实例管理范围问题，即哪些定时任务由有哪个服务实例发起。
3. 定时任务管理配置分发问题，即当配置发生改变时应该发送到那个服务实例，如果各个实例内配置相同，如何发送到各个实例。

### 解决方案

解决方案分两种场景：

1. 多实例任务管理配置相同。
2. 多实例任务管理配置不同，所有实例的任务管理配置并集为实际任务管理需求。

#### 多实例配置相同

在该场景下，多实例往往没有价值，唯一的价值在于服务定时任务的**容错性**。即实例分布在不同节点/区域，当位置影响任务，导致任务失败后，其他正常节点可以正常运行。但这种能力**一般在服务内即可实现容错**重试，并提供健康探测接口，利用的底层平台能力(例如K8S)，使得服务节点迁移与重试。

根据#2.1中描述，需要在多实例定时任务执行时做到，相同定时任务的**幂等性、隔离性和原子性**

* 幂等性：多实例任务定时器下，不同实例的相同任务(可能根据实际业务，时间点上会有差异性)执行不会导致不同结果，即相同任务执行的幂等性
* 隔离性：相同任务在同时执行是相互隔离的，不会相互影响。例如交叉执行。
* 原子性：整个任务的执行是原子的。

例如通过将任务执行状态外置到外置存储，在执行定时任务时首先获取任务分布式锁，通过分布式锁保证不会同时有多个相同任务执行(隔离性)，通过获取任务状态比对预期状态，决定是否执行，如何执行(幂等性)，对任务的执行结果外置(某种程度的原子性)

#### 多实例配置不同

该场景下，往往是由于定时任务执行器的性能或节点计算资源压力，导致需要对定时任务执行器进行扩展。因此模型往往是原本的定时任务管理服务被划分为**定时任务管理实例**与**任务执行器实例**，管理实例负责对任务进行分发、实现分布式事务和结果统筹，执行器负责执行具体任务。

jenkins就是类似的模型，只是它不仅支持定时任务，还支持事件源监听和触发。

该场景中同样需要注意任务的**幂等性、隔离性和原子性**，并根据实际业务进行设计。

这种解决方案的本质其实是一种计算调度框架，通过管理节在工作节点上调度。将有状态应用拆分，将状态下沉到底层服务，将上层应用状态变为无状态应用。

### 总结

如果只是定时任务，往往不需要考虑多副本实例，但是要**做好自身的健康管理和相关任务状态的外置**。当出现性能和资源分配问题时，通过计算调度框架和实际业务进行设计。

对于在容器调度平台上，如K8S等，应该通过某种方式限制第一种场景下的实例最大数量或**副本数量控制策略**，但允许多副本时应该要处理好相同定时任务的**幂等性、隔离性和原子性**。

## 应用利用本地卷存数据

该场景下应用实例需要本地存储存储临时数据，这里又根据数据类型划分为两种情况：

1. 临时数据
2. 持久化数据

### 多实例问题

在本地存储多实例，如果扩展为多节点，将会可能导致数据一致性问题。

### 解决方案

#### 临时数据

对于临时数据，应该考虑降低临时数据的重要性，以及数据丢失的容错力，将**临时数据下沉到底层存储，临时数据元数据外置到底层存储**。

例如临时数据不使用本地磁盘，而是使用内存进行缓存，并立即存储到最终存储。

对于存在角色划分的服务实例内的数据，应该考虑角色管理，以及在临时数据丢失后的数据重发。

##### 对象存储代理场景

例如服务A作为对象存储的数据中间层，为上层应用提供同一的接口和入口时，通过分片上传的方式，每次A服务接收分片立即通过对象存储的分片上传接口到第三方存储。

若第三方服务未提供分片上传，对于大数据量文件应该将分片状态进行管理，并外置到分片元数据管理数据库，最终提交文件时，汇聚数据并上传到对象存储，又或者是通过外置底层存储临时存储各个分片。

在出现分片数据错误时要求客户端重发，或在代理前增加临时存储如kafka，实现相关容错机制。

当某个实例出现异常后，不需要依赖于本地存储文件，可以要求客户端重发数据或重新消费缓存数据。

#### **持久化数据**

该场景主要常见于底层存储服务，如mysql集群、对象存储集群、etcd集群、网络存储卷管理集群等。需要考虑相应集群化管理方案，以保证数据节点扩展时的**数据重平衡**，通过集群算法保证数据操作的**ACID**。

如果上层应用出现该场景，应该考虑实现集群算法或数据下沉到底层存储集群方案。、

### 总结

一般持久换存储已经有相应方案和可用产品。

对于自开发的服务应该首先考虑利用**底层存储机制实现数据下沉**和**元数据管理**。其次再考虑实现集群算法，对集群系统的管理。

# 三、服务实例角色划分

这种有状态应用服务实例一般会有特定的角色划分，同时基于角色的不同，可能会使用本地存储保存持久化数据，也有可能仅仅是根据角色的划分进行不同的操作。

因此可以根据这两种情况进行不同方式的管理。由于存在角色的划分，因此一定需要**角色的管理策略**。

这种场景种服务副本的数量是不可以随便增加的，而是根据角色管理策略、**实例角色管理工具**进行扩缩容。

例如一个基于消息队列的数据流，不考虑最终底层存储的情况下，角色划分可以划分为，生产者，缓存队列和消费者。消费者从缓存队列种消费数据，进行数据处理并最终存储到底层存储。

这个过程中如果存在消费能力不足是，数据堆积的情况，需要增加消费者实例数量以增强消费能力。且在业务上要求数据的顺序性和无重复，不通过实例角色管理工具而是直接增加消费者服务实例，则可能会导致增加的消费者实例与其他实例消费同一topci，同一分区、同一队列的数据。那么这里由于不同实例的处理进度的不同将会导致数据在最终存储的**乱序**，若最终存储处不能自动去重（大数据量下都是不会做基于ID去重的，一般去重操导致随机写，不去重为顺序写，性能差别很大）则可能会导致**数据重复**。

因此扩展消费者时应该通过工具，增加缓存队列实例内的队列，对数据进行重平衡，对生产者的提交进行重分配等。该操作由这种**系统管理工具**和实例角色管理工具，完成一系列配套的操作。





