# 一、概括

几种常见策略如下

## 隔离

对服务内部请求进行划分，在网格上对通过流量管理能力可以实现对服务接口的隔离控制。可以认为是对服务的基于功能和接口的细粒度控制。这种细粒度控制包含且不仅限于熔断、限流。

从网络管理层完成服务级别的隔离，复杂度在于`隔离的划分`、服务向基础运维团队如何交付`服务隔离性说明`，以及`隔离性规则管理`的复杂性问题。

## 降级

这种策略往往是在某种基于策略下动态的对服务状态进行诊断，在某种状态下对服务进行网络上的状态迁移。例如k8s的健康检测，在健康检测策略下控制服务是否可以通过service访问。

如果是在服务性能上，更多的做法进行`扩容`。动态扩容需要服务提供细粒度性能报告，并基于动态的服务指标监控，实现hpa机制进行扩容。

## 超时机制

超时机制分为两种，一种是访问外部服务的超时设置，一种是外部访问自身服务的超时设置。

### 访问外部服务

访问外部超时设置，一般在服务内部是必然会有一定设置的(没有就是服务开发有问题)，很少需要从网络层进行处理。需要从系统层调控的原因可能有：

* 从整体系统角度的统一考量与服务默认定义不符需要调整，需要服务服从整体配置，但服务未提供配置接口或希望直接从平台层统一设置。(如果服务未提供接口，则`网络层配置范围一定小于等于服务内配置`)。
* 根据实际生产环境需要，需要进行调优。

这种机制的复杂问题在于`外部服务的定义、集成和管理`，以及系统是否需要统一考量和如何考虑

### 外部服务访问自身服务

非自研系统和自研的其他组件都可以认为是外部服务。这种状态下也很少需要网络层进行超时机制的设置，这种从网络层对服务访问进行超时限制的机制本质上是对`细粒度服务健康状态的外置定义`。

这种行为最关键的两个问题在于：

1. `服务的健康定义`在细粒度上如何定义
2. 服务在外部服务断开连接后，不会继续处理已终止连接的请求(或者说等待处理的请求)，可以安全的终止处理到一般的事务。(这个是目前一些服务却没有做到的，从而导致对头阻塞后，仍花费大量时间处理已终止请求，对外现象就是卡死)

## 熔断

大量的请求可能会在某些异常发生时出现或外部的恶意攻击时发生。当大量请求进入服务时可能会导致服务崩溃，通过熔断机制可以对服务进行熔断保护。个人认为熔断时降级的一种策略。

问题复杂性在于如何确定`服务熔断策略`和`运维熔断策略`。

在ISTIO官方中对熔断的实现适用于http和tcp协议，通过对服务的扫描策略，如果连续返回异常(如503)或者连接数超量，则会根据熔断策略将后端服务从可用池中踢出配置的时间。

## 限流

对服务的输入输出进行限制，避免服务超出预估峰值带来的影响，从而保证服务的持续正常运行。

在istio网格中是利用envoyfilter对象完成对流量的限速。本质上是利用了envoy的[ratelimit](https://www.envoyproxy.io/docs/envoy/latest/api-v3/service/ratelimit/v3/rls.proto)，envoy会根据自身代理的情况设置若干钩子，并对在流量到达特定钩子时根据`ratelimit`设置和内部统计监控指标信息进行决定是否拒绝服务。



## 总结

实际上不论是降级、熔断、限流还是超时，都是有其策略的`隔离性要求`的，因此除了策略自身的实现外，还需要定义`隔离性`我们可以将它认为是一种划分层次和管理的粒度，系统层的隔离性和服务级别的隔离性，以及各种`隔离性`下服务和系统需要进行的`交付物`。

例如限流，哪些服务需要限流，http服务接口是否根据URI要区分限流策略，对应的基准性能如何影响限流策略。



# 二、在istio下各策略实践与实现原理

暂略

