[toc]

# 一，现状

目前服务间的安全认证行为分为两种，一种为外部服务的请求认证，一种是内部服务间的身份认证。

1. 第一种外部请求认证，通过用户登录授权，获得对应的token，使用token作为认证凭证。
2. 第二种为微服务安装部署时进行服务注册，获取对应的客户端ID，通过客户端ID作为认证凭证。

以上两种认证行为都是在微服务接收到请求后，通过认证服务器接口对请求的认证信息进行认证和授权认证。即真正的认证仍为认证服务完成

可以认为整个认证流程如下:

```
1. client --- get_token/get_client_id ---> auth_server
2. client --- request(token/client_id)---> micro_server 
     										|---- micro_server ---auth(token/client_id)---> auth_server
   client <---- return resource			----|

```

对于第一种认证常常用于浏览器或客户端，第二种往往用于向第三方开放服务或用于内部服务连接。



### 二、网格与系统的通信安全

![](C:\Users\tiga.gan\Desktop\deploy.svg)

上图为某次分享时的网络通信结构。该结构下的通信安全仍有已有的安全系统保证。两个集群的安全认证依赖于同一个认证系统，实现请求级别的安全认证与授权。如果此时基于安全认证和授权行为下沉到平台的目的，假设将istio网格内的已有认证移除，进一步分析网格和整个系统的的通信安全。



## 2.1 网格的通信安全

### 2.1.1 内部服务间的通信

参考第一节所说两种认证方式，在内部服务间的访问实际并不需要请求级别的认证。理由是clientID仅在部署时确认，而不是像web登录一般需要频繁变更(相对)。内部服务间的认证大多是为了确定对方是否是可信的内部服务，这种行为可以利用istio的连接级别认证确保内部服务间的通信安全。

istio提供的连接级别认证会将服务间的通信升级为双向的tls认证与安全命名验证从而确保内部服务间的安全通信与识别，认证行为由sidecar完成。如果目前系统



### 2.1.2 网格对外提供服务的安全

网格对外提供的服务的安全如果移除当前的认证系统后，如上图所示，外部请求都是经过网格后负载到网格内的服务，因此时的安全将被网格的安全策略控制(也可以在pod级别上控制，但不是主要论点，暂且忽略)。网关同样支持连接级别的认证和请求级别的认证，但如果去除应用层的认证后，那么有两种外部服务流量。 

1. 第一种系统的内部服务流量，但部署在网格之外，这种通信同样可以通过连接级别的认证完成对外部服务的认证，具体方法我们在第三节介绍。
2. 第二种系统外部的服务流量，例如客户端或前端。这种流量的特点在于客户端的多变性以及认证和授权行为更复杂。这种通信的认证往往基于请求级别的认证，例如hydra。istio提供了基于jwt的请求级别认证(虽然号称支持任何OpenID Connect的认证实现，但没找到实例)，那么假设将目前的hydra认证去除，那么将会造成请求级别的认证安全风险。但是我们可以将内部服务间的hydra客户端去除，转为依赖连接级别的认证。



## 2.2 网格外系统的通信安全

这里所说的网格外系统，主要指的是整个产品的内部服务但非部署在网格内的服务。例如上图所示右半部分的集群。目前该集群的通信安全由已有的hydra系统保证。但根据其通信对象，假设去除hydra系统后，存在以下问题

1. 非网格服务与网格内服务通信时，将会缺少连接级别的安全认证，从而使得非网格服务无法通过网格内服务的认证。可以考虑通过保证集群内通信安全的基础上，使得集群间的通信完成连接级别的认证，解决方案我们在第三节详细讨论。
2. 外部服务与非网格服务的通信安全，此时由于缺少认证系统，将无法保证安全的请求。因此我们可以考虑通过保证集群内通信安全的基础上，基于安全网关的方案对外提供开放API，详细方案我们在第三节讨论



### 2.1.3 风险点

1. **已有的内部服务间通信还存在授权行为**，istio虽然也提供了一些连接级别的授权策略，需要根据需要进一步分析是否满足。



# 三、基于istio的整体系统通信安全探讨

基于istio系统的通信安全有多种部署结构多种方案，这里通过一个比较简单的方案作为讨论起点。

![](E:\study\distribute system\ns\istio\images\safe_deploy.svg)

上图所示为一种系统间通信的模型(一种部署结构，尚未实验成功，但可以基于这个进行讨论)。图中istio集群代表了网格内的服务，并代表了一个集群。as集群为系统内其他非网格内服务所在集群。

## 3.1 网格内服务

首先介绍istio内部的通信，istio内部的通过连接级别的认证保证通信安全，istio对外提供服务是通过一个安全网关(可以简单当作一个可进行认证、授权行为的nginx)对外暴露内部服务。其他非网格内集群(集群间)通过该安全网关，通过连接级别的安全策略访问网格内的集群(图中上方的黄线)。外部服务(例如页面端)的请求进入到网关时，由网关完成请求级别的认证(其实在pod上进行也可以)。从而完成了网格内服务对内部服务和外部请求的安全保障。



## 3.2 网格外服务

其次，可以查看右边的非网格内集群。在这个集群中其实有部分服务会被服务网格所控制，即图中蓝色部分的网关，这些网关可以完成网关外和网关内服务通信的流量升级与安全保证。注意接下来的讨论基础是**集群内通信安全**(涉及范围为图中红色的线条)。

0. 由于**集群内通信安全**的基础，非网格内服务在同一集群内访问同一集群内的网格网格是安全的。

1. 当非网格内的内部服务访问网格内服务时(访问其他集群)，数据流量将会通过网格内的`ingress-contrl`经由图中第一条黄线，跨集群访问，此时集群的间的两个网格会自动完成双向的tls认证，完成连接级别的安全认证行为。由于**集群内通信安全**的基础，非网格内服务在同一集群内访问同一集群内的网格网格是安全的。
2. 当网格内的服务访问非网格内的内部服务(其他系统内部集群访问本集群)，数据流量会经由图中下方的黄线通过本集群网格内的网关`gateway`进入本集群，最后集群内的流量抓发到集群内部服务。此时集群间的通信，是基于网关内的网关进行，网格内的网关会自动完成连接级别的认证，从而保证集群间的通信安全。
3. 到此，系统内部间的通信安全已经的得到一定程度的保证。那么外部的请求如何保证保证安全。如图上所示，当客户端发送请求到系统中时。如图中绿线所示首先会经过的是系统中的安全网格，那么在安全网关上完成请求级别的安全认证将可以得到安全的保证。但是这里有一个风险，由于实际微服务实例不在网关控制内，可能无法实现pod级别的授权策略控制，以满足场景。



## 3.3 请求级别的token签发

这里涉及到token该由谁签发，怎么签发以及整个用户的授权流程。目前个人对当前hydra系统的使用理解是当token无效时，web端跳转到登陆页面，通过hydra进行签发后重新跳回原页面。那么图中的`auth server`就要能够完成对应的行为。



## 3.3 风险

1. 在非网格内集群上，由于实际微服务实例不在网格控制内，实际安全由网关保证，可能无法实现pod级别的授权策略控制，以满足场景。
2. 非网格内集群的集群内部通信安全如何保证？
3. istio 是否真的可以集成hydra，如果不可以是否改用jwt？如果坚持使用hydra自己写安全网关似乎并不可靠
4. `auth server`性能、逻辑等



# 四、风险与执行难点

1. **已有的内部服务间通信还存在授权行为**，istio虽然也提供了一些连接级别的授权策略，需要根据需要进一步分析是否满足。
2. 在非网格内集群上，由于实际微服务实例不在网格控制内，实际安全由网关保证，可能无法实现pod级别的授权策略控制，以满足场景。
3. 非网格内集群的集群内部通信安全如何保证？
4. **istio 是否真的可以集成hydra**，如果不可以是否改用jwt？如果坚持使用hydra自己写安全网关似乎并不可靠。
5. `auth server`性能、逻辑等
6. 请求级别的安全认证行为下沉到平台的过程也许不能一蹴而就，那么混合情况下，就需要**所有微服务**支持是否启用自身服务认证的能力。是不是考虑请求级别的认证下沉行为延后。
7. 多个集群的证书管理，如果是网格内的证书，那么由网关进行管理，但是如果是请求级别的证书(或者说凭据)，该如何管理，如果有多个证书，将会有可能又需要**所有微服务**支持根据通信目标选择证书(通信方式)的能力，这里还附带另一个风险，就是微服务还得知道对方的位置，不大好。

