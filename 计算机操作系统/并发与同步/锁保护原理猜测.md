# 疑问

为什么通过基于cas的锁能够就能保护锁作用域内的多个变量，使得多cpu内线程间可用形成受保护的临界区。看到的很多关于锁实现中仅仅介绍cas操作了锁内部的值，那有没有其他没有介绍的机制保证作用域内变量安全？

# 猜测

关键字：以下原理猜测相关的技术关键词有锁，cpu多级缓存，cpu缓存一致性的snoopy和mesi协议，指令重排，内存屏障。



```
init state: {x=0, y=1}
-------------------------
T0 in cpu0:
lock()
tmp = x
x =tmp +1
y+=1
unlock()
--------------------------
t1 in cpu1:
lock()
tmp = x
x = tmp + 1
y+=1
unlock()
-----------------
end state: {x=2, y=3}

```

将问题展开描述，如上文的计算中，锁使用了原子操作进行相关的cas计算，确保自身的值在两个cpu间不会存在错误的值。

但此时的x和y并没有执行原子操作，那么即使同一时间内的只有一个cpu中的线程在执行，再执行完成后是否能保证cpu间的缓存能在另一个cpu执行前做好同步吗？那如何保证cpu1的缓存与cpu0计算后的保持一致呢？如果不能确保缓存保持一致，那么最终结果可能和预期的最终结果不同，例如`{x=1, y=2}`。

在很久以前的想法是，在对变量进行计算和赋值时，cpu0会更改缓存，更改内存，并通知其他cpu1更新缓存或缓存失效。

但是cpu可能进行指令重排，编译器可能进行代码优化重写等行为。编译器和cpu如何确定lock()和unlock()内部各个变量的关系？

后来再次看到一直没理解透的内存屏障部分，内存屏障可以实现对编译优化和cpu乱序执行和指令重排进行指示，因此猜测是否是锁的实现中除了最基本的cas外还结合了内存屏障能力，从而实现锁作用域内指令的顺序性，以及确保相关变量在cpu缓存一致性的一致。

例如cas结合内存屏障，确保lock()之后的操作不会在lock()之前执行，在unlock()之后恢复cpu的乱序执行等。

# 验证

暂时没有想到方法



# 知识关键字

1. <<深入理解计算机系统>>
2. <<深入理解linux内核>>
3. c++同步原语
4. golang内存可见性官方文档
5. rust锁使用方式