# V1

## 数据结构

```rust
/// 定义在某块内存上的数据操作
pub struct data{
    class: u8,
    offset: u32,
}

/// 定义在某块内存上的字符串数据操作
pub struct name {
    offset: u32,	
}
```

```rust

/// 数据节点两种节点的枚举，提供统一抽象
pub enum Node {
    Internal(InternalNode),
    Leaf(LeafNode)
}

/// 叶子节点，对应文件系统的文件
pub struct LeafNode {
    class: u8,
    lower: 	Option<Rc<RefCell<Node>>>,		    // 底层同名节点指针，常为空，因此生命周期应小与底层同名节点a
    data:	Rc<Data>,				    // 数据指针，生命周期应小于数据存储b
    layer: 	Rc<InternalNode>,			// 节点所在层指针， 节点所在层本质上是一个根节点为"/"的InternalNode，因此生命周期应小于父节点
    name:  Rc<Name>,				   	// 节点名称指针, 生命周期应小于数据存储d
}

/// 内部节点的生命周期大于其子节点，子节点的生命周期跟随父节点，父节点拥有子节点
/// 理论上内部节点应该为其子节点的所有者，应该负责其对子节点的释放工作。
/// 存在的一个问题是节点描述符需要引用多个节点，节点描述符生命周期应小于真实节点生命周期。
/// 内部节点，对应文件系统的目录
pub struct InternalNode {
    /// 标识
    class: u8,

    /// 底层同名节点指针，可能为空，因此生命周期应小与底层同名节点a
    lower: 	Option<Rc<RefCell<Node>>>,		

    /// 数据指针，生命周期应小于数据存储b
    data:	Rc<Data>,				

    /// 节点所在层指针， 节点所在层本质上是一个根节点为"/"的InternalNode，因此生命周期应小于父节点
    /// 存在一个问题，如果这个节点就是根节点，那么自己指向自己是不合理的
    layer: 	Rc<InternalNode>,		

    /// 节点名称指针, 生命周期应小于数据存储d
    name:  	Rc<Name>,				

    /// 父节点拥有子节点
    /// 如果将InternalNode存储在连续的内存块上，应该考虑children的存储表示， todo
    children:	Vec<Rc<RefCell<Node>>>,
}

```
```rust
pub struct NodeDescriptor<'a> {
    path: Vec<&'a Node>		// 根节点到当前节点的路径，所以其生命周期应该小于node节点的最小生命周期
}
// path数组元素可能会在运行时改变，变为其他节点引用，因此NodeDescriptor的可能会超过某些节点的生命周期，在静态语义分析时可能会导致无法通过，如何处理这种矛盾？

impl <'a>NodeDescriptor<'a> {
    // 实现写时复制，path路径复制到最上读写层
    // self的path会被替换为最上层节点，这个过程引发生命周期变化
    // self初始生命周期依赖于各个数据层，经过写时复制后依赖于最上层
    // 如何处理这个生命周期的变化
    fn cow(&mut self, layers)
}
```

一个文件系统的入口为`InternalNode`，名为"/"。每一层数据层都是一个根节点。

基于这个结构的一个对外提供的数据视图，分为最上层的读写层和若干个只读的低数据层。构建视图时需只需要创建一个新的数据层，其"/"节点的`lower`链接低层。

对视图的修改，需要首先经过cow，再完成对应节点的调整。一旦某层数据完成，则不应该继续对数据节点进行修改，如果需要修改应该通过创建新数据层完成。

如果想要将其应用到不断追加的内存块(文件块)中，难点在于如何设计内部节点在内存中的表示，而内部节点的表示难度在于如何设计其子节点的链表存储。子节点链表中的指针在内存中可能会是连续的，也可能是离散的。考虑内部节点"/"和"/root",按顺序创建了"/root/test","/tmp","/proc"，那么对于"/"节点的子节点链表，只有"/tmp"和"/proc"在内存上紧密相连，但与"/root"无法紧密相连，因为在这之前创建了"/root/test"，在内存上"/"内部节点的子节点列表的三个指针在内存上第一个与后两个隔着一个数据节点。如果完全使用链表表示，那么在需要使用额外的内存位，并且链表读取性能低于数组的直接寻址。

这里存在的问题是，由于每层都没有办法复用节点信息，如果要在最上层对数据节点进行调整，则需要复制数据节点路径上所有节点的信息，导致其内部节点数量膨胀(节点名和子节点列表不复制，因为保存路径信息仅仅是为了获得节点入口)。



### todo

在文件系统中目录项可以进行缓存，并通过hash快速查找，这块代研究。也许可以解决每一层都需要保存路径节点的问题。

文件系统的数据写是将磁盘分为最小数据块进行，待研究，也许可以解决内部节点的子节点的不连续问题。



## 应用

如果想要将这个东西应用到arrow或msg上，以解决这些技术在数据构造完毕后难以再次调整内容，需要拆包复制后再重写的问题，在多个arrow或msg上进行联合视图，提供自下而上或自上而下的视图。

