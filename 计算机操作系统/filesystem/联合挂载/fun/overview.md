## overview

类似docker镜像，类似aufs，类似overlay文件系统，将数据分层，最终呈现给使用者的是特定连续层数合并后的数据。对数据的每次修改都会创建新的数据层。以此实现以增待删改的行为。

带来的好处是可以获得特定时期的数据，并且可以从特定时期数据发展出不同的分支。

这样的想法在数据处理流中的一个好处在于一个数据事件如果需要同时经过不同模块的处理生成两个新的数据，那么这两个数据在底层能够共用相同的数据层，新增的仅仅是自身的schema信息以及一层新数据层，可以极大的减少数据的内存占用以及数据复制带来的额外开销。

同样的想法在配置管理中可以做到配置的版本管理。在虚拟机中的快照管理由类似的行为，每次快照都是从上次快照位置的增量快照。

所以是否可以有这么一个东西能够在定义一系列行为后，能够快速的让开发者完成一个新联合挂载系统的使用。



## how to

### 数据节点唯一标识问题

参考联合挂载文件系统，docker镜像的联合挂载计数应用，可以发现它们最基本的合并粒度是文件。两层数据中有相同路径的文件会，下层文件会被上层文件覆盖。而从整体文件系统视角来看，唯一的标识为文件路径，对数据的查找方式为文件的逐层查找。再联合挂载文件系统中，数据层的合并自下而上，如果出现相同文件则被上层文件覆盖或添加上"空白涂改液"。因此遇到的第一个问题是数据的粒度设置和数据的唯一标识，如何数据合并的最细粒度是多少，数据层间的冲突如何识别。

### 数据节点的查询问题

联合挂载文件系统以文件路径为数据查询途径，那么对于一个分层的数据其查询的路径该如何设置。对于一个普通的数据事件，例如logstash中的event、splunk中的日志又或数据库表的行，数据内部的查询途径可以根据他们的schema设定。

对于一个业务系统中的配置，可以是对于配置在业务上的唯一标识。对于已有的业务系统的逻辑基本确定。但这个逻辑的设定影响了其查询性能



### 数据层元信息合并策略

使用者最终查看的是多个连续数据层的合并视图，那么什么时候进行合并，如何合并，是否需要合并。

* 如果在使用时合并，那么在需要使用数据时需要额外的数据合并时间，例如如果容器启动时进行镜像层合并，那么可能会导致容器启动较慢。而且并非特别适合以增代删改的思想。本质上是自下而上的合并，但是由于没有保留每一次的合并信息，因此每次使用前需要重新合并。
* 如果在每一层都做合并，新的一层仅与下层做合并，那么合并性能提升，但是带来的问题是每一层都需要维护合并后的数据节点信息，结合数据节点过多问题可能会导致数据空间的额外使用。本质上是自下而上的合并，并保留了每一层的合并层。
* 不做合并，在查询时逐层查询。这样可以去除合并的性能开销(实际上在每一层生成时进行了部分合并，因为每一层数据节点需要下一层保存根节点到数据节点路径上的内部节点信息)，本质上是自上而下的合并。数据节点的查询可能会出现跨层访问或者跨多层访问的情况，当数据层过多时可能会导致数据访问性能问题。如果将两层数据的同名数据节点关联，对比合并与不合并有差异：
  * 数据节点可能存在多层，查询需要跳转。
  * 查询内部节点下特定节点，由于数据可能仅在最下层，而查询必须从最上层开始(有没有别的方法？)，每层使用二分查找，查询时间复杂度为O(m×h×lgn)，n为数据节点的数量，m为数据层数, h为目录深度 
  * 当查询节点为内部节点时，需要对内部节点的子节点列表进行合并(也许可以不做合并，如果不需要打印，而仅仅作为数据节点入口)

因此自下而上合并方式与自上而下得到合并方式优点在于其查询性能更高，写入方便，不需要保存根节点到数据节点的路径信息。缺点在于如果多个数据处理模块对相同的底层数据进行操作时，则需要对合并层信息(数据节点索引树)  进行复制(写时复制)消耗额外的空间。

自上而下的合并可以仅合并需要的节点，而不需要合并所有节点，这样的特性使得他在运行时可以使用更少的空间(不需要索引树，数据层自身持有路径信息，使用时仅需要打开部分数据层数据)。但如果需要将所有的数据层都打开，那么使用额外的索引树比将索引存储在各个数据层间更节省空间，因为数据层间存储的路径会存在重复，可能会n倍。

overlay文件系统会将数据层分为上层与下层，在搜索查询时，搜索两层数据层。从某种意义上来说是对底层数据进行合并为只读层。可写层与只读层不做合并，而是在读写时做联合处理。

#### 数据节点过多问题

在联合挂载文件系统中文件即为其数据节点。一个logstash或splunk的event数据，在经过多次的转换中内部数据的不断转换导致其schma的变化带来的很大的困难。event在个人的理解中更像是一个不断嵌套的map类型，从而保证了其在数据处理过程中的灵活性。考虑这么一个问题："map的某个字段下是一个长度不定的数组，这些数组的每个值可能是数组，也可能是一个map，也可能是一个基本类型，那么该如何设计出一个数据结构和查询方式来查询到特定的数据"。这个问题类似于“文件系统的根目录下可能有文件，也可能有目录”，但是问题在于文件系统下一个目录的数量不会太多(或者说在整体上存在一定的限制，例如inode数量限制)，但是map下某个字段的数组的数量似乎无法存在这样的限制，特别是在数据处理过程中使用者似乎也很难对此做出限制，因此可能会导致数据节点过多的问题。



### 自上而下的合并面临的问题

#### 数据节点内容修改问题

类似于容器进行数据修改时会在容器层进行数据添加。如果对一个目录下的文件内容进行修改或是对数组内的一个数据进行修改，这意味着需要在当前数据层增加一个数据节点并能够覆盖低层数据节点，这里的问题在于其父数据节点同样需要修改，那么如何维护这个联系。那么从上一个问题继续，在文件系统中一个目录包含了其目录下的文件信息，如果修改目录下的文件信息，意味着这里的目录可能也需要通过新增数据节点的方式完成，但如果是数组下子节点的修改，会导致数组整体信息的修改，这个可能带来性能上的影响。

解决办法：上层数据节点仅包含新增节点信息，如果出现目录下文件修改的情况，则将上层的数据目录节点与下层进行结合，数据节点关系的合理性由下层数据保证。

#### 自上而下数据节点在数据层间关联问题

从上一个问题继续，如果当前数据层新增的数据节点为上一数据层某个数据节点的子节点，那么如何维护两个数据节点间的关系？如何在各个数据层中表示相关联的两个数据节点。

在overlay中的解决办法是在上层同时持有关联的两者，在查询时对两者进行合并。例如对于上层的目录会持有新增文件的信息，但不会持有下层已有 文件信息，在查询时会将上层中的目录和下层对于目录的文件进行合并。合并策略有：

* 上层已存在则不加入下层同名节点
* 上层已删除文件新增删除数据节点，下层对应同名节点不加入
* 上层不存在数据节点，下层存在则加入。
* 上层数据以增代删改。

这里有一个问题在于查询到某一层的内部节点时，期望的子数据节点在其他层，那么查询其他数据层时又会需要再次从数据层根入口逐个节点查询，因此会带来额外的性能消耗。因此考虑在对应的数据节点上设置低层同名数据节点的指针，当目标数据节点不在该节点下时，直接通过指针跳转到低层同名数据节点，避免了在低层数据节点再次查找已查找的同名节点问题。



#### 自上而下内部数据节点冗余与数据节点存在判断问题

如果采取类似overlay的方式，那么新增的数据节点其父节点的信息无法与子节点复用，可能造成数据重复。例如下层中含有"/root/tmp/1"文件，则上层需要增加数据节点时需要构造"/root/tmp"路径节点信息。并且引来另一个问题是当需要获取"/root/tmp"下数据时，需要对两层数据"/root/tmp"目录内的节点进行集合并集处理，如果数据层较多则可能造成性能下降。

多层内部节点取并集的算法：每层内部节点的子节点按字典序(或数据节点标识规则递增排序)，在进行并集计算时从第一层开始获取。考虑存在两层数据节点，从上至下为[1,3,5,10,13,14,15], [1,2,6,7,8,9,11]。那么取并集的问题就会变为数组2对数组1的插入与重排序问题。

对于取并集在插入时会尽可能的插入大块的有序片段，而不是一个个节点进行插入，这样可以减少数据移位带来的开销。算法如下

从两个数组的游标从首部(0)开始，比较两个数组元素，存在以下情况与处理方式：

	* 数组2元素等于数组1，则两个数组游标向后移动，跳过当前元素
	* 如果数组2元素大于数组1且left标记为空，标记当前数组1游标为left，数组2游标记为start，数组1游标向后移动。
	* 如果数组2元素小与数组1且start非空，数组2游标后移
 * 如果left标记不为空且数组2元素大于等于数组1，则标记数组1游标为right，数组2游标记为end。此时需要将数组2的stat->end元素有序的插入数组1。随后将各个标记置空。继续合并
    * 方式一直接插入数组1尾部后对数组进行移位，设交换重排的数组1为[1, 2, 3, 5, 9, 10, 13, 14, 15, 6, 7, 8]。此时letf指向5，right指向9，需要将片段为[6,7,8]到left之后，right之前
      	* 即需要将数据从right开始右移3位
      	* [1, 2, 3, 5, 15, 14, 13, 10, 9, 8, 7, 6] --> [1, 2, 3, 5, 6, 7, 8, 9, 10, 13, 14, 15]
      	* 该方式最少需要`(length-right + end-start )*2`次数据赋值(一次数组1交换，一次数组2插入，一次相关片段交换，所以时间复杂度为O(length-right),好处是不需要额外空间
    * 另一个方式为对数组1扩容3个后，将当前的right之后复制到队尾后，再插入数组2片段
      	* [1, 2, 3, 5, 9, 10, 13, 9, 10, 13, 14, 15] -> [1, 2, 3, 5, 6, 6, 8, 9, 10, 13, 14, 15] 
      	* 该方法需要对数组1进行`length-right`次赋值,时间复杂度为O(length-right)。
   * 因此采用第二种方式
   * 这里有一个隐含问题，那就是数组1的长度问题，数组1与其他数组的不断融合使得数组1可能会不断的进行扩容，从而产生数据复制。这个可以从父节点间的属性解决在数组1创建时尽可能的准备好足够的容量。



#### 数据层元信息合并问题

使用者最终查看的是多个连续数据层的合并视图，那么什么时候进行合并，如何合并，是否需要合并。

* 如果在使用时合并，那么在需要使用数据时需要额外的数据合并时间，例如如果容器启动时进行镜像层合并，那么可能会导致容器启动较慢。而且并非特别适合以增代删改的思想。本质上是自下而上的合并，但是由于没有保留每一次的合并信息，因此每次使用前需要重新合并。
* 如果在每一层都做合并，新的一层仅与下层做合并，那么合并性能提升，但是带来的问题是每一层都需要维护合并后的数据节点信息，结合数据节点过多问题可能会导致数据空间的额外使用。本质上是自下而上的合并，并保留了每一层的合并层。
* 不做合并，在查询时逐层查询。这样可以去除合并的性能开销(实际上在每一层生成时进行了部分合并，因为每一层数据节点需要下一层保存根节点到数据节点路径上的内部节点信息)，本质上是自上而下的合并。数据节点的查询可能会出现跨层访问或者跨多层访问的情况，当数据层过多时可能会导致数据访问性能问题。如果将两层数据的同名数据节点关联，对比合并与不合并有差异：
  * 数据节点可能存在多层，查询需要跳转。
  * 查询内部节点下特定节点，由于数据可能仅在最下层，而查询必须从最上层开始(有没有别的方法？)，每层使用二分查找，查询时间复杂度为O(mlgn)，n为数据节点的数量，m为数据层数。
  * 当查询节点为内部节点时，需要对内部节点的子节点列表进行合并(也许可以不做合并，如果不需要打印，而仅仅作为数据节点入口)

因此自下而上合并方式与自上而下得到合并方式优点在于其查询性能更高，写入方便，不需要保存根节点到数据节点的路径信息。缺点在于如果多个数据处理模块对相同的底层数据进行操作时，则需要对合并层信息(数据节点索引树)进行复制(写时复制)消耗额外的空间。并且自上而下的合并可以仅合并需要的节点，而不需要合并所有节点，这样的特性使得他在运行时可以使用更少的内存(不需要索引树，数据层自身持有路径信息，使用时仅需要打开部分数据层数据)。



#### 数据膨胀与数据节点数量问题

由于数据分层，因此可能会出现同一个数据节点在多个数据层出现的情况，出现数据重复，因此可以考虑在数据需要压缩或数据交换时进行数据层的合并形成新的数据层作为基础层再进行交换。典型的场景为日志事件在进程内进行处理后需要传递给其他进程或其他服务，并且其他服务并不需要历史数据层。此时如果不对数据层进行合并，将会浪费额外的传输流量，与数据膨胀。因此可以考虑在数据输出时对数据层进行合并后转换为特定的格式使用数据交换技术对数据进行交换。

##### 自上而下的合并数据节点浪费问题

如果采用自上而下的合并行为，由于最上层数据节点需要保存根节点到数据节点的内部节点作为数据入口，会导致数据层内数据节点数量增加。



#### 自上而下合并数据层生成时机与数据写入问题

如果每个操作都生成一个数据层，那么可能会造成数据节点的浪费。因为每个数据节点的添加都会记录其父节点的信息。

数据节点的修改需要判断在当前数据层创建新数据节点，可以考虑通过设置节点所在层标识判断，当所在层非最上层时则需要创建新的数据节点。

数据节点的创建需要获得下层同名数据节点以及根节点到数据节点的信息，以此创建当前数据层的写入的数据节点的内部节点路径。在linux文件系统中打开一个目录会以文件的形式打开，并且会记录查找信息、保存查找起始路径。对路径查找的每一个分量都会保存查找结果。因此需要在目录下创建子目录或文件时可以直接根据这些信息进行创建。每个文件操作都基于这个file对象进行操作。

有没有什么方式可以不保存数据节点的父节点信息，或在写入时不需要父节点信息，或能够快速获取路径上各个节点的信息。

* 每层数据层同名的数据节点，理论上其名称标识应该是相同的，唯一不同的是类型与数据内容。叶子节点差异在于数据内容，内部节点差异在于子节点列表/链表。有没有什么方法能做到父节点信息复用。这样在创建新节点时不需要获取父节点信息。但是在保证下层数据不被上层数据修改的情况下如何做到？
* 分布式数据库中的以增代删是如何做到的，如果数据库每加入或修改一条数据都需要增加相应的内部节点路径信息，数据库表岂不是会膨胀得很厉害？(数据库有主索引，而且数据库查询的索引树会不断根据数据进行调整，并在需要进行数据合并时调整数据库文件内容，它只有一颗树，可以认为这颗树是从最底层不合并数据层，需要更底层时再重新从最底层合并，也就是“使用时从下至上合并”策略。而这里的场景是不合并，查询时从上至下合并，SB) 
  * 是否可以考虑从下往上的合并策略，始终维护一个最上层的树。要获取特定层的视图则需要从底层开始合并需要把写入、修改操作抽象为**事件**操作。最终事件操作可以形成视图树。此时在当前层的每个事件都会增加事件，并修改视图，也就是说数据层内保存的不是数据节点，数据节点仅为逻辑概念，实际保存的是**事件**。由事件持有数据。即事件构建视图，视图提供查询，对视图的修改变为事件的生成。那么如何完成**事件** <------> **视图**的转换
    * 在数据库中是通过主键完成事件的描述，通过对主键值唯一确定数据在树上的位置。以此完成数据的增删改查事件，那对于文件系统类型的路径作为主键，是否可以考虑使用字典序进行。这也许比自上而下的查询要好。对视图的操作可以简略定义为：
      * delete -> (node_delete, tree, key), (record_info, deleted_node)
      * rename -> (new_key, st, newkey), (delete_node,st, oldkey), (new_node, new_key,old_data), (node_insert, tree, node)
      * update -> (new_value, st, data), (node_update, tree, key, data)
      * new -> (new_key, st, key)，(new_value, st, data), (new_node, key, data),(node_insert, tree, node)。在存储新增两个数据，数据为主键值，与数据值。在索引树上根据主键值对应位置增加视图节点，视图节点指向数据值与主键值
      * search -> (search, tree, key)
      * 这样一个模式就将数据层变为事件集合。
    * 据此可以设计回退行为：
      * delete_rolllback -> (read_recoed, deleted_old), (node_insert, tree, deleted_node)
      * rename_rollback -> rename old_name
      * update -> (node_update, tree, key, old_data)
      * new -> delete
      * 需要注意的是回退操作不会对已保存的新数据(主键值，数据内容)做任何修改，并且回退过程中节点重新指向了旧值。因此如果下次有新的数据以同样的数据内容或主键值添加时即使有相同的数据已经保存在存储区，也无法复用。类似ABA‘问题，即使A’与A相同，但本质上已经不是同一个对象，不过如果这个值本身就是对其他对象的引用，那么占用的空间也不会太大，在数据压缩时由于内容相同可以被压缩，也可以在需要压缩数据大小时将相关数据层进行合并。

### 自下而上合面临的问题

#### 合并的索引树保存时机

如果每一次修改和调整后的索引树都保存则可能造成浪费，如果都不保存，在使用时则需要重新自下而上进行构造。



有没有什么办法或策略将两者结合？

自上而下，入口在每个数据层中含有，自下而上只有1个。如果上层存一棵树，下层存一颗合并树。先找上树，不存在则跳转到下树。最后数据层成型后再刷新上层树。

有没有可能在自下而上的基础上引入事件？



#### 索引树选择

如果使用二叉树，将数据节点名称作为唯一标识，使用字典序进行排序，需要进行rename操作时不仅需要重排命中节点，还需要重排其子节点。





### 无端联想

arrow，msgpack等技术都是为了进行数据交换的特别技术，但是它们的缺点在于一旦数据填写完毕，无法再对其进行改动。是否可以通过以增代删改，联合挂载的思路，在此基础上进行多数据层的联合视图。