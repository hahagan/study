## etl功能设计

### 整体数据流管理

etl负责基于角色的方式管理数据流中各个组件，当前的数据流组件经过改造后如下图所示

![](D:\study\search\megaminx\images\etl.png)

该数据流管理可以抽象为下图，etl通过接口，将系统的状态描述为上图。

![](D:\study\search\megaminx\images\etl管理.jpg)

为了达成这个目的，etl需要支持基于角色的组件管理管理。实际上角色这个概念也可以扩展到kafka和elasticsearch，每个角色代表一个满足特定功能的组件集群。

### 数据流图形化管理

#### 两层图形管理

将整个数据流分为三层，第一层为数据流组件与角色组合图，用于查看整体数据流的构成与调整整体数据流结构，展现各个组件角色间的关联。对第一层图形进行下专，形成第二层图形，第二层图形为指定角色的规则规则或配置展开，展示单个角色间内部的数据流转。所有的数据流配置操作都应基于这两层图形进行。

第三种图形为第一种图形的变形，数据流中不以角色为单位，而是以实例组成数据流图，该图不允许进行修改，仅能进行状态查看。未来可能会结合部署进行实例状态管理。

### 数据流规则管理

#### logstash

logstash每个角色中解析规则分为input,filter和output进行管理。分别对应数据源，解析规则和输出源。所有配置规则保存在mysql中，生成的logstash配置文件，按角色对应etcd分组保存到etcd中。

未来etcd仅用于完成logstash实例的配置文件同步。每次etl服务启动/重启时都应该从数据库中获取配置规则，重新生成logstash配置文件，并同步到etcd中。文件内容存在差异才会触发logstash的服务更新。另外如果能够通过远程触发的方式触发logstash的更新，可以考虑去除etcd，但是目前没发现logstash提供相关api接口，也许可以通过编写一个和logstash的sidecar服务对本地logstash进行管理。

##### 增删改查

logstash更新较慢，如果需要监控请求给logstash变更带来的状态变化整个任务的生存时间会拉长。考虑使用异步非阻塞请求，但是需要前端调整请求方式。下面描述的是同步接口，请求可能会造成超时，当然可以不考虑监控logstash状态。

1. 添加插件
   1. 解析解析规则内容，合法性检查，资源预留
      1. 使用异步非阻塞的接口，可以在合法性检查通过后，进行资源预留，然后直接返回任务ID
   2. 生成新logstash配置文件并根据分组存入的etcd分组中
   3. 监控logstash各个实例的更新状态
      1. logstash热更新(实际是整个pipeline的重启)速度很慢，因此如果是同步接口可能会导致服务阻塞以及请求超时，导致任务状态丢失。
      2. 如果出现logstash启动失败(logstash似乎没有更新失败接口)，对etcd配置进行回滚。结束新增任务，后续状态在logstash服务状态管理中查看
   4. logstash各个实例重启成功后，将解析规则存入数据库
   5. 返回成功
2. 删除插件
   1. 删除插件后配置生成，合法性校验
   2. 调整etcd内容
   3. 监控logstash实例状态
   4. 更新数据库
3. 修改插件
   1. 解析解析规则内容，合法性检查，资源预留
      1. 使用异步非阻塞的接口，可以在合法性检查通过后，进行资源预留，然后直接返回任务ID
   2. 生成新logstash配置文件并根据分组存入的etcd分组中
   3. 监控logstash各个实例的更新状态
      1. logstash热更新(实际是整个pipeline的重启)速度很慢，因此如果是同步接口可能会导致服务阻塞以及请求超时，导致任务状态丢失。
      2. 如果出现logstash启动失败(logstash似乎没有更新失败接口)，对etcd配置进行回滚。结束新增任务，后续状态在logstash服务状态管理中查看
   4. logstash各个实例重启成功后，将解析规则存入数据库
   5. 返回成功
4. 获取插件对象
   1. 从数据库中获取
5. 禁用插件
   1. 调正etcd内容
   2. 监控logstash实例状态
   3. 更新数据库
6. 启用插件

##### 配置回退方案

类似docker镜像层管理，每次对数据流的改变会生成一个配置的镜像层。

回退策略有两种，一种是直接回退到特定的镜像层，另一种是删除本次配置对应的镜像层后进行镜像层合并，形成最新镜像层。

在需要进行回退时通过将对应镜像层进行删除，后合并镜像层得到当前配置。镜像层合并优先级按时间顺序从早到晚，优先级逐渐变高。

考虑使用镜像层方式进行回滚的原因是，两个时间点内进行的配置可能存在交集，而我们的配置可能仅会在某个时间点出现错误，并且仅需要去除某次的配置。



### 角色管理

### logstash管理

### vector管理

### kakfka配置

### 实例状态管理

