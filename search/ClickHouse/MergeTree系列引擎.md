## TTL

* 列级别TTL：过期数据中对应列变为默认值
* 表级别TTL： 满足过期条件行被删除

### TTL运行机制
1. 以分区为单位，通过ttl.txt记录过期时间，作为后续判断依据
2. 每批数据写入都会基于interval表达式生成分区的ttl.txt
3. 只在合并分区时触发数据TTL过期处理逻辑
4. 选择删除的分区时会使用贪婪算法，尽可能找到最早过期，年纪最大的分区
5. 如果一个分区内某列因为TTL全部被删除，那么合并后生成的分区目录中，不存在这个列字段的原始数据和索引

## 多路径存储策略

1. 默认：所有分区自动保存到config.xml指定的目录下
2. JBOD：轮询策略，每次INSERT或者MERGE时，轮询写入各个磁盘，以降低单块磁盘的复制。在一定条件下增加数据并行读写的性能
3. HOT/COLD：HOT采用高性能存储，注重存取性能，COLD采用高容量存储，注重经济性。数据写入时，数据首先写入HOT，当分区数据大小达到阈值时，数据自行移动到COLD区域。HOT/COLD两个区域也支持定义多个磁盘

## 分区生成与合并策略
分区并非在表创建时创建，而是在数据写入时创建。MergeTree每一批数据写入(一次INSERT语句)都会生成一批新的分区目录。即使不同批次写入的数据属于相同分许，也会生成不同的分区目录。在之后的某个时刻(写入后的10~15分钟，或手动执行optimize)，ClickHouse会通过后台任务将相同分区的多个目录合并为一个新目录。已存在的旧分区目录不会被立即删除，而是之后某个时刻通过后台任务删除(默认 8 分)

## 多种MergeTree
1. RepalcingMergeTree
    * 场景用途：MergeTree拥有主键，单主键没有唯一约束，因此可能会存在重复数据。用户在某些情况下不希望存在重复数据，RepalcingMergeTree能在合并分区时一定程度删除重复数据
    * 处理逻辑：
        1. 使用ORDER BY 排序键作为判断重复数据的唯一键
        2. 只有在合并分区时触发重复数据删除
        3. 以数据分区为删除重复数据单位，分区合并时同一分区重复数据被删除。不同分区不会被删除
        4. 由于已进行ORDER BY 排序，因此删除仅需要删除连续的相邻重复数据
        5. 数据去重两种策略，如果每设置ver版本号，保留同一组重复数据最后一行。如果设置了ver版本号，保留ver字段值最大一行
2. SummingMergeTree
    * 场景用途：用户不关心明细数据，并且对数据的汇总条件时预先明确的。SummingMergeTree在合并分区时按照预先定义的条件汇总数据，将同一分组下的多行数据汇总合并为一行
    * 处理逻辑：
        1. 用ORDER BY排序键作为聚合数据的条件KEY
        2. 只有在合并分区的时候才会触发汇总逻辑
        3. 以数据分区为单位来聚合数据。分区合并时，同一分区内聚合KEY相同的数据，不同分区不汇总
        4. 定义时如果指定了汇总列，则汇总指定列，否则汇总所有非主键的数值字段
        5. 汇总时已经过ORDER BY 排序，因此只需要合并相邻且相同KEY数据
        6. 汇总数据时，同一分区内，相同KEY多行数据合并为一行，汇总字段进行SUM计算，非汇总字段取第一行值
        7. 支持嵌套结构，但字段名必须以Map结尾。汇总时默认以第一个字段作为聚合KEY。如果任何字段以Key，Id或者Type结尾可以与第一字段组成符合KEY

3. AggregatingMergeTree
    * 场景用途： AggregatingMergeTree在合并分区时，按照预先定义的条件聚合数据。常用的使用方式不是直接用于数据表，而是结合物化视图与普通MergerTree进行使用。在数据表作为底层数据表，物化视图使用AggregatingMergeTree对底层表进行聚合并存储
    * 处理逻辑：
        1. ORDER BY排序键作为聚合数据的条件KEY
        2. 使用AggregateFunction字段类型定义的聚合函数的类型以及聚合字段
        3. 合并分区时触发聚合计算的逻辑
        4. 以数据分区为单位聚合数据，同一分区内的数据进行合并，不同分区数据不会被计算
        5. 聚合数据时，相同KEY行合并为一行，聚合字段进行聚合计算，非聚合字段取第一行值
        6. 数据计算由于已进行ORDER BY 排序，因此可以连续计算相邻项
        7. AggregateFunction类型字段使用二进制保存，写入时需要调用*State函数；查询时需要调用相应*Merge函数

4. CollapsingMergeTree
    * 场景用途： 数据库对已存在数据实现行级修改或删除。在高性能分析型数据库中，对数据源文件修改代价高昂。相较于直接修改源文件，他们将修改和删除操作转换为新增操作，即增代删
    * 处理逻辑：
        1. 通过定义sign标记为字段，记录数据行状态。sign为1表示行有效。sign为-1，表示行需要删除
        2. 分区合并时sign的1和-1的一组数据会被抵消删除，这被称为数据折叠
        3. 合并分许时，相同分区的数据进行折叠，不同分区数据不会折叠
        4. 数据折叠并非实时的，而是在合并分区时进行
        5. 折叠数据时遵守以下规定：
            * 1比-1多一行，保留最后一行sign=1数据
            * -1比1多一行，保留第一行sign=-1数据
            * 1和-1一样多，最后一行为sign=1，保留第一行sign=-1和最后一行sign=1
            * 1和-1一样多，最后一行为sign=-1，不保留
            * 其余情况打印警告日志，不报错，查询结果不可预知
        6. CollapsingMergeTree对写入顺序有严格要求，单线程执行可以较好控制写入，但是多线程并行处理，衲衣保障数据的顺序写入，为解决这个问题提供了VersionedCollapsingMergeTree

5. VersionedCollapsingMergeTree
    * 场景用途： 与CollapsingMergeTree作用相同，但是对数据的写入顺序没有要求
    * 处理逻辑：
        1. 除sign标记字段外，额外需要一个Uint8类型的ver版本号字段
        2. 在定义ver字段后，将其作为排序条件增加到ORDER BY 末端，保证每个分区内数据按照ORDER BY排序，保证数据写入后，在折叠数据时都是正确的顺序


## 疑问
数据分区没10-15分钟进行一次合并，那么在分区合并之前，各种MergeTree的数据处理逻辑没有触发，例如去重，那么岂不是在这期间进行的查询操作会包含重复数据。这个延时是否太高了？
