## vector多行处理

### 主要配置有
* start_pattern: 决定多行时间开始的正则表达式，当正则匹配时进入多行合并处理流程
* timeout_ms: 超时时长，当时间到达时强制生成事件
* mode: 多行合并的处理流程
* condition_pattern: 正则表达式，在多行合并处理流程开始后对每一块数据进行正则，如果匹配则根据mode配置进行相应处理

### 多行合并主要成员
_inner: 负责数据IO层，对多个文件进行数据IO
_buffer: std::collections::HashMap，其key值为IO层的数据来源唯一标识


### 处理流程
1. 通过_inner进行poll操作，获取从数据源获取一个数据块
2. 通过判断对应数据源是否已有数据存储在_buffer中，进行数据处理
* 如果_buffer中不存在对应数据源，则对start_pattern进行正则，如果匹配则开始多行合并流程，将其加入_buffer中，否则视为单行事件处理
* 如果_buffer中已存在对应数据源，则对数据块进行condition_pattern的正则匹配，并根据mode进行处理
    * mode为`ContinueThrough`时，如果匹配则为多行事件中的一部分，如果不匹配则将已有数据作为新事件，当前数据作为新事件开头
    * mode为`ContinuePast`时，如果匹配则为多行事件中的一部分，如果不匹配则将已有数据与当前数据作为新事件，并去除_buffer中的对应数据源数据
    * mode为`HaltBefore`时，如果不匹配则为多行事件中的一部分，如果匹配则将已有数据作为新事件，当前数据作为新事件开头
    * mode为`HaltWith`时，如果不匹配则为多行事件中的一部分，如果匹配则将已有数据与当前数据作为新事件，并去除_buffer中的对应数据源数据

## logstash多行处理
### 主要配置有
* pattern: 正则，当数据匹配后，根据what设置对数据进行处理
* what: 决定多行

### 处理流程
1. INPUT层传入一个数据块，将数据库"\n"切分，
2. 再对每一行进行pattern正则匹配
    * 如果该行不匹配，则将其作为当前事件的一部分，加入缓存
    * 如果匹配，根据what配置，将缓存数据what定义输出当前事件并生成新事件


## splunk多行合并处理
