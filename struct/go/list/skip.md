# 跳表
![avatar](https://img-blog.csdnimg.cn/2019093001060565.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NDEyNTc5,size_16,color_FFFFFF,t_70)

## 时间复杂度
增删改查时间复杂度为O(log n)

原理是通过多级索引进行查询对应元素，而相邻级别的索引间满足上级节点数量为下级节点数量的两倍。每级索引中节点都是有序排序的，并且相同序位值的索引可以直接从上级指向下级，在查找过程中其行为表现类似于二分查找。

对于节点数量为n的跳表，查找时最差情况下需要进行O(log n)次跳表(即从上级跳到下级相同节点)，并且每次跳级需要从当前节点遍历直到找到目标节点返回或未在该级找到继续跳表。跳表后，不会再次遍历已查询节点，因此实际查找时间为 m * log(n)，m最大值为每级节点数量。然而m的值满足二项分布，且节点的排序也同样满足二项分布(大体上尽可能),在每级索引上的查找不会为其节点最大值，而是同样为log(m)。因此平均的查找时间复杂度为O(log n)。

## 空间复杂度
跳表空间复杂度为O(n)

包含原始数据链表在内的空间n，以及多级索引空间，约为 n + m * log(n)，所以理论上空间会变为原空间的1-2倍

## 实现

### 插入数据的索引级别选择
在实现中为了让数据在插入到跳表时尽可能的满足其二项分布，在插入时，通过随机函数，让数据所在级别概率，在下级永远为上级的2倍。如此不需要预先知道每个级别的节点数量也可以尽可能的满足数据在空间上的分布。

### 数据结构
在本实现中数据节点同时会保留当前节点的为序和值，同时通过next数组记录后继节点在所有级别的位置
而链表结构中只保留头指针、级别、长度等信息，通过头指针的next数组可以获得每级索引中的第一个元素。尾指针更多的是用于在代码中确定是否遍历结束，实际上可以通过判断是否为空替代

### 未实现的链表存储
思考过实际上next数组也可以通过链表作为底层存储结构，但是好处仅仅是存储可不连续，但是带来的坏处是在跳级后，读取next元素时需要从第一个元素起遍历读取，增加时间复杂度。

## 参考链接
[jianshu.com/p/400d24e9daa0?from=timeline&isappinstalled=0]()

[https://blog.csdn.net/qq_34412579/article/details/101731935]()
